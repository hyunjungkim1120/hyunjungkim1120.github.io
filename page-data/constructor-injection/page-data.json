{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/constructor-injection",
    "result": {"data":{"markdownRemark":{"id":"356fb14a-5cc1-5ebe-9923-5e8c649685d2","html":"</br>\n<h3>Dependency Injection (의존관계 주입)</h3>\n<p>의존성을 주입하는 방법을 고민하기 전 DI(의존관계 주입)에 대해 간단히 짚고 넘어가자.</p>\n<p>DI는 객체지향 프로그랭밍에서 중요한 개념으로 <strong>\"외부에서 두 객체 간의 관계를 결정해주어 유연성을 확보하고 결합도를 낮출수있다\"</strong> 가 핵심이다.</p>\n<p>우리는 한객체가 다른 객체를 사용할때 의존성이 있다라고 이야기한다. 예를 들어 A 객체에서 B 객체를 사용하고 있는경우 A가 B에 의존성이 있다고 표현한다.</p>\n<p>아래의 코드를 보자</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Programmer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">JavaLanguage</span> language<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Programmer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>language <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JavaLanguage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</br>\n<p>Programmer객체는 JavaLanguage에 의존성이 있고 JavaLanguage대신 CplusplusLanguage로 변경하려면 Programmer Class를 수정해 주어야한다.</p>\n<p>DI를 통해 결합도를 낮춘 아래 코드를 살펴보자</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Programmer</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Language</span> language<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Programmer</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Language</span> language<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>language <span class=\"token operator\">=</span> language<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 Language를 생성자에서 주입 받으면 Programmer 에서는 수많은 language에 대해 고민하지 않을 수 있고 Language를 상속받은 JavaLanguage, CplusplusLanguage 등을 사용할 수 있다. </p>\n<p>즉, B Class를 수정할때 A Class도 같이 수정해야하는 상황을 막을 수 있다.</p>\n</br>\n</br>\n<h3>Spring의 의존관계 주입 3가지</h3>\n<p>💡 <strong>수정자 주입(Setter)</strong></p>\n<ul>\n<li>setter는 public으로 외부 접근이 가능하며 변경 위험이 있고 이는 치명적 결함으로 이어질수 있다. </li>\n</ul>\n<p>코드는 아래를 참고하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderService</span> <span class=\"token punctuation\">{</span>\n \n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Discount</span> discount<span class=\"token punctuation\">;</span>\n \n  <span class=\"token annotation punctuation\">@Autowired</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setDiscount</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Discount</span> discount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  \t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>discount <span class=\"token operator\">=</span> discount<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</br>\n<p>💡 <strong>필드 주입(@Autowired)</strong></p>\n<ul>\n<li>코드가 간결하다는 장점이 있지만 외부 변경 불가로 테스트 시 어려움이 따른다</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderService</span> <span class=\"token punctuation\">{</span>\n \n  <span class=\"token annotation punctuation\">@Autowired</span>\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">Discount</span> discount<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</br>\n<p>💡 <strong>생성자 주입</strong></p>\n<ul>\n<li>생성자 호출시점 1번만 호출하고 final을 활용하여 불변을 보장할 수 있다.</li>\n<li>\n<p>순환참조를 방지한다. </p>\n<p>=> A와 B가 서로가 서로를 참조하는 경우 필드주입의 경우에는 서버구동시에도 오류가없고 해당 부분이 동작해야 에러가 발생한다. 하지만 생성자 주입은 순환참조시 서버가 구동되지않고 에러를 확인할 수있어 이를 바로 방지할 수 있다.</p>\n<p>이는 빈을 주입하는 순서가 다르기 때문이다.(필드 주입과 수정자 주입은 빈을 먼저 생성한후 주입하려는 빈을 찾아 주입하지만, 생성자 주입은 주입하려는 빈을 먼저 찾고 빈을 생성한다)</p>\n<p><strong>따라서 순환참조를 방지하려면 생성자 주입을 권장한다.</strong></p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrderService</span> <span class=\"token punctuation\">{</span>\n \n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Discount</span> discount<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token annotation punctuation\">@Autowired</span> <span class=\"token comment\">//생성자가 하나일 경우 @Autowired 생략 가능</span>\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">OrderService</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Discount</span> discount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  \t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>discount <span class=\"token operator\">=</span> discount<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</br>\n<p>Lombok의 도움을 받아서 위의 코드를 더욱 간단하게 사용할 수도 있다.</p>\n<p>생성자 주입에서 class에 @RequiredArgsConstructor를 사용하면 final이나 @NotNull을 사용한 필드에 대한 생성자를 자동으로 생성해준다.</p>\n</br>\n<h2>참고자료</h2>\n<ul>\n<li><a href=\"https://woodcock.tistory.com/8\">생성자 주입이 좋은 이유와 다양한 DI 방법</a></li>\n<li><a href=\"https://jackjeong.tistory.com/41\">생성자 주입 vs 필드주입(@Autowired)</a></li>\n</ul>","excerpt":"Dependency Injection (의존관계 주입) 의존성을 주입하는 방법을 고민하기 전 DI(의존관계 주입)에 대해 간단히 짚고 넘어가자. DI…","frontmatter":{"date":"January 28, 2022","slug":"/constructor-injection","title":"생성자 주입, 필드 주입, 수정자 주입의 비교","description":"의존관계 주입의 간단한 개념과 수정자 주입, 생성자 주입, 필드 주입 장단점 비교","featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/bd0791d00fbe25290707bc6bebe5c907/4a49b/constructorInjection.jpg","srcSet":"/static/bd0791d00fbe25290707bc6bebe5c907/37bba/constructorInjection.jpg 750w,\n/static/bd0791d00fbe25290707bc6bebe5c907/61c72/constructorInjection.jpg 1080w,\n/static/bd0791d00fbe25290707bc6bebe5c907/4a49b/constructorInjection.jpg 1280w","sizes":"100vw"},"sources":[{"srcSet":"/static/bd0791d00fbe25290707bc6bebe5c907/a66aa/constructorInjection.webp 750w,\n/static/bd0791d00fbe25290707bc6bebe5c907/65dd5/constructorInjection.webp 1080w,\n/static/bd0791d00fbe25290707bc6bebe5c907/71d4d/constructorInjection.webp 1280w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5625}}}}}},"pageContext":{"id":"356fb14a-5cc1-5ebe-9923-5e8c649685d2","previous":{"id":"83274ff8-d1f6-52f6-a169-49660b017d46","frontmatter":{"slug":"/restControllerAdvice","template":"blog-post","title":"RestControllerAdvice 예외처리"}},"next":{"id":"ad8bf59c-8216-5411-a891-df61445ce4b5","frontmatter":{"slug":"/lessons/92344","template":"algorithm-post","title":"파괴되지 않은 건물(프로그래머스) Java"}}}},
    "staticQueryHashes": ["228695001","2744905544","358227665"]}